# -*- coding: utf-8 -*-
"""Untitled1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1yCw2GfhxwX5e1ihWPle4GgcfOv3mkfsz

## init
"""

pip install google-generativeai langgraph langchain gradio

import google.generativeai as genai
from google.api_core.client_options import ClientOptions

openwather_api_key = "17084f2cf7cc52c3f245f8fc68c147fe"

metis_api_key = "tpsg-kweH1WRiC1a8N6a723wtYLKLASpPHFt"

genai.configure(api_key=metis_api_key, transport='rest',
                client_options=ClientOptions(api_endpoint="https://api.tapsage.com"))

llm = genai.GenerativeModel("gemini-2.0-flash")

output = llm.generate_content("hello how are you today?").text

output

"""## Agent 1

"""

from typing import Dict, TypedDict, List
from langgraph.graph import StateGraph

class AgentState(TypedDict):
  message : str

def greeting_node(state: AgentState) -> AgentState:
  """ Simple Greeting Node """

  state["message"] = "Hello " + state["message"] + " How are you? "

  return state

graph = StateGraph(AgentState)

graph.add_node("greeter" , greeting_node)

graph.set_entry_point("greeter")
graph.set_finish_point("greeter")

app = graph.compile()

from IPython.display import Image, display
display(Image(app.get_graph().draw_mermaid_png()))

result = app.invoke( { "message" : "Akbar" } )

result

"""Agent 2"""

import sys, subprocess, os, requests, datetime
import google.generativeai as genai
from langgraph.graph import StateGraph, START, END
from pydantic import BaseModel, Field
from langchain_core.prompts import PromptTemplate
from langchain_core.output_parsers import JsonOutputParser

class TripState(TypedDict):
    user_input: str
    city: str
    user_interests: List[str]
    weather_info: str
    final_itinerary: str

"""**Interest**"""

class InterestSchema(BaseModel):
    interests: List[str]

interest_parser = JsonOutputParser(pydantic_object=InterestSchema)

interest_prompt = PromptTemplate.from_template(
    "Extract a concise json list of user interests (max = 3 most important) from the following request. {format_instructions}\nRequest: {user_input}"
).partial(format_instructions=interest_parser.get_format_instructions())

def interest_node(state: TripState):
    prompt = interest_prompt.format( user_input=state["user_input"] )
    result = llm.generate_content(prompt).text

    parsed_result = interest_parser.parse(result)

    state["user_interests"] = parsed_result["interests"]
    return state

# debug

fake_state: TripState = {
    "user_input": "Ù…Ù† Ø§Ø² Ø¯ÙˆÚ†Ø±Ø®Ù‡ Ø³ÙˆØ§Ø±ÛŒ Ùˆ Ø´Ù†Ø§ Ø®ÙˆØ´Ù… Ù…ÛŒØ§Ø¯ Ùˆ Ø¢Ø®Ø± Ù‡ÙØªÙ‡ Ù‡Ø§ Ø¯ÙˆØ³Øª Ø¯Ø§Ø±Ù… ÙÛŒÙ„Ù… Ø¨Ø¨ÛŒÙ†Ù… Ùˆ Ø¨Ù‡ Ú¯Ù„ Ù‡Ø§Ù… Ø±Ø³ÛŒØ¯Ú¯ÛŒ Ú©Ù†Ù….Ù‡Ù…Ú†Ù†ÛŒÙ† Ø§Ø² Ø³ÙØ± Ø®ÛŒÙ„ÛŒ Ø®ÙˆØ´Ù… Ù…ÛŒØ§Ø¯ Ùˆ Ø¯ÙˆØ³Øª Ø¯Ø§Ø±Ù… ØªÙˆÛŒ Ø¢Ø¨ Ù‡Ø§ÛŒ Ø¢Ø²Ø§Ø¯ Ø´Ù†Ø§ Ú©Ù†Ù….",
    "user_interests": [],
    "weather_info": "",
    "final_itinerary": ""
}

fake_node = interest_node(fake_state)

print(fake_node["user_interests"])

"""**Weather**"""

def fetch_weather(city: str, start_date: datetime.date, days: int = 1):
    url = f"https://api.openweathermap.org/data/2.5/forecast?q={city}&appid={openwather_api_key}&units=metric"
    try:
        data = requests.get(url, timeout=30).json()
        forecasts = []

        for entry in data.get("list", []):
            dt = datetime.datetime.fromtimestamp(entry["dt"]).date()
            if start_date <= dt < start_date + datetime.timedelta(days=days):
                forecasts.append({
                    "timestamp": entry["dt"],
                    "date": dt.isoformat(),
                    "weather": entry["weather"][0]["description"],
                    "temperature": entry["main"]["temp"],
                    "feels_like": entry["main"]["feels_like"],
                    "humidity": entry["main"]["humidity"],
                    "wind_speed": entry["wind"]["speed"],
                    "pressure": entry["main"]["pressure"]
                })

        return {
            "city": city,
            "start_date": start_date.isoformat(),
            "days": days,
            "forecasts": forecasts,
            "status": "success" if forecasts else "no data available"
        }
    except Exception as e:
        return {
            "city": city,
            "start_date": start_date.isoformat(),
            "days": days,
            "forecasts": [],
            "status": "error",
            "error_message": str(e)
        }

# debug

city = "London"
start_date = datetime.date.today()
days = 1

result = fetch_weather(city, start_date, days)

result

import json

def weather_node(state: TripState) -> TripState:
    user_input = state["user_input"]

    # LLM call to find correct city name for OpenWeatherMap API
    city_prompt = f"""
    Extract the destination city from this user input: '{user_input}'

    Task:
    1. Identify the city the user wants to travel to (input may be in any language)
    2. Return the standardized English city name compatible with OpenWeatherMap API

    Examples:
    - Input: 'Ø³Ù„Ø§Ù… Ù…Ù† Ù‚Ø±Ø§Ø±Ù‡ Ø¨Ø±Ù… Ø§ØµÙÙ‡Ø§Ù† Ùˆ Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ù…ÛŒØ®ÙˆØ§Ù… Ø§Ø² Ø§ÙˆÙ†Ø¬Ø§' â†’ Output: Esfahan
    - Input: 'I want to visit New York' â†’ Output: New York
    - Input: 'Planning a trip to æ±äº¬' â†’ Output: Tokyo

    Rules:
    - Return only the city name in English
    - Use the exact spelling recognized by OpenWeatherMap API
    - If no city is found, return "CITY_NOT_FOUND"
    - No additional text or explanations

    City name:"""

    corrected_city = llm.generate_content(city_prompt).text

    if (corrected_city == "CITY_NOT_FOUND"):
      forecast = "No data is available about weather."
      state["city"] = ""
    else:
      today = datetime.date.today()
      forecast = fetch_weather(corrected_city, today, days=1)

      # LLM call to generate 5-line summary in Persian
      summary_prompt = f"""
      You are given the following weather forecast JSON data for {corrected_city}:
      {json.dumps(forecast, indent=2, ensure_ascii=False)}

      1. Generate a 5-line summary in Persian describing the weather conditions, including temperature, humidity, wind speed, and general weather description for the forecast period. Ensure the summary is concise and natural.
      2. Don't say Here's a 5-line summary in Persian based on the provided weather forecast data for city_name, just return the summary in Persian.

      """
      weather_info = llm.generate_content(summary_prompt).text

      state["city"] = corrected_city

    state["weather_info"] = weather_info

    return state

# debug

fake_state: TripState = {
    "user_input": " Ù…Ù† Ø§ØµÙÙ‡Ø§Ù†ÛŒ Ø§Ù… Ùˆ Ù‚Ø±Ø§Ø±Ù‡ Ø§Ø² ØªÙ‡Ø±Ø§Ù† Ø¨Ø±Ù… ØªØ¨Ø±ÛŒØ²",
    "user_interests": [],
    "weather_info": "",
    "final_itinerary": ""
}

fake_node = weather_node(fake_state)

print(fake_node["weather_info"])

"""**Itinerary**"""

class ItinerarySchema(BaseModel):
    itinerary: str

itinerary_parser = JsonOutputParser(pydantic_object=ItinerarySchema)

itinerary_prompt = PromptTemplate.from_template(
    """You are an expert Persian-speaking travel planner with extensive knowledge of global destinations. Create a comprehensive {days}-day itinerary for {city}.

    Ù…Ø´Ø®ØµØ§Øª Ø³ÙØ±:
    - Ø¹Ù„Ø§ÛŒÙ‚ Ù…Ø³Ø§ÙØ±: {interests}
    - Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ø¢Ø¨ Ùˆ Ù‡ÙˆØ§: {weather}
    - Ù…Ø¯Øª Ø³ÙØ±: {days} Ø±ÙˆØ²

    Ø¯Ø³ØªÙˆØ±Ø§Ù„Ø¹Ù…Ù„â€ŒÙ‡Ø§ÛŒ Ù…Ù‡Ù…:
    - ØªÙ…Ø§Ù… Ù¾Ø§Ø³Ø® Ø¨Ø§ÛŒØ¯ Ø¨Ù‡ Ø²Ø¨Ø§Ù† ÙØ§Ø±Ø³ÛŒ Ú©Ø§Ù…Ù„ Ø¨Ø§Ø´Ø¯
    - Ø§Ø² Ø§ÛŒÙ…ÙˆØ¬ÛŒâ€ŒÙ‡Ø§ÛŒ Ù…Ù†Ø§Ø³Ø¨ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ú©Ù†
    - Ø¨Ø±Ù†Ø§Ù…Ù‡ Ø±Ø§ Ø¨Ø± Ø§Ø³Ø§Ø³ Ø¢Ø¨ Ùˆ Ù‡ÙˆØ§ Ùˆ Ø¹Ù„Ø§ÛŒÙ‚ Ø´Ø®ØµÛŒâ€ŒØ³Ø§Ø²ÛŒ Ú©Ù†

    Ø³Ø§Ø®ØªØ§Ø± Ø®Ø±ÙˆØ¬ÛŒ Ù…ÙˆØ±Ø¯ Ù†ÛŒØ§Ø²:

    #### ğŸ™ Ù…Ø¹Ø±ÙÛŒ Ø´Ù‡Ø± {city}
    - ØªÙˆØ¶ÛŒØ­ Ú©Ù„ÛŒ Ø¯Ø±Ø¨Ø§Ø±Ù‡ Ø´Ù‡Ø±
    - ÙˆÛŒÚ˜Ú¯ÛŒâ€ŒÙ‡Ø§ÛŒ Ù…Ù†Ø­ØµØ± Ø¨Ù‡ ÙØ±Ø¯
    - Ø¨Ù‡ØªØ±ÛŒÙ† Ø²Ù…Ø§Ù† Ø¨Ø§Ø²Ø¯ÛŒØ¯

    #### ğŸ—“ Ø¨Ø±Ù†Ø§Ù…Ù‡ Ø±ÙˆØ²Ø§Ù†Ù‡ ({days} Ø±ÙˆØ²)
    Ø¨Ø±Ø§ÛŒ Ù‡Ø± Ø±ÙˆØ² Ø´Ø§Ù…Ù„:
    - ØµØ¨Ø­ (8:00-12:00): ÙØ¹Ø§Ù„ÛŒØªâ€ŒÙ‡Ø§ Ùˆ Ù…Ú©Ø§Ù†â€ŒÙ‡Ø§ÛŒ Ù¾ÛŒØ´Ù†Ù‡Ø§Ø¯ÛŒ
    - Ø¸Ù‡Ø± (12:00-15:00): Ø±Ø³ØªÙˆØ±Ø§Ù†â€ŒÙ‡Ø§ Ùˆ ØºØ°Ø§Ù‡Ø§ÛŒ Ù…Ø­Ù„ÛŒ
    - Ø¹ØµØ± (15:00-18:00): Ø¬Ø§Ø°Ø¨Ù‡â€ŒÙ‡Ø§ÛŒ Ú¯Ø±Ø¯Ø´Ú¯Ø±ÛŒ
    - Ø´Ø¨ (18:00-22:00): ÙØ¹Ø§Ù„ÛŒØªâ€ŒÙ‡Ø§ÛŒ Ø´Ø¨Ø§Ù†Ù‡ Ùˆ Ø³Ø±Ú¯Ø±Ù…ÛŒ

    #### ğŸ› Ù…Ú©Ø§Ù†â€ŒÙ‡Ø§ÛŒ Ø¯ÛŒØ¯Ù†ÛŒ Ø§ØµÙ„ÛŒ
    - ÙÙ‡Ø±Ø³Øª Ú©Ø§Ù…Ù„ Ø¬Ø§Ø°Ø¨Ù‡â€ŒÙ‡Ø§ÛŒ Ú¯Ø±Ø¯Ø´Ú¯Ø±ÛŒ
    - Ø§ÙˆÙ„ÙˆÛŒØªâ€ŒØ¨Ù†Ø¯ÛŒ Ø¨Ø± Ø§Ø³Ø§Ø³ Ø¹Ù„Ø§ÛŒÙ‚ Ù…Ø³Ø§ÙØ±
    - Ø²Ù…Ø§Ù† Ù¾ÛŒØ´Ù†Ù‡Ø§Ø¯ÛŒ Ø¨Ø±Ø§ÛŒ Ù‡Ø± Ù…Ú©Ø§Ù†

    #### ğŸ½ Ù¾ÛŒØ´Ù†Ù‡Ø§Ø¯Ø§Øª ØºØ°Ø§ Ùˆ Ø±Ø³ØªÙˆØ±Ø§Ù†
    - ØºØ°Ø§Ù‡Ø§ÛŒ Ù…Ø­Ù„ÛŒ Ø­ØªÙ…ÛŒ
    - Ø¨Ù‡ØªØ±ÛŒÙ† Ø±Ø³ØªÙˆØ±Ø§Ù†â€ŒÙ‡Ø§ Ø¯Ø± Ù‡Ø± Ù…Ù†Ø·Ù‚Ù‡
    - Ù…Ø­Ø¯ÙˆØ¯Ù‡ Ù‚ÛŒÙ…Øª

    #### ğŸšŒ Ø­Ù…Ù„ Ùˆ Ù†Ù‚Ù„
    - Ø¨Ù‡ØªØ±ÛŒÙ† Ø±ÙˆØ´â€ŒÙ‡Ø§ÛŒ Ø¬Ø§Ø¨Ø¬Ø§ÛŒÛŒ Ø¯Ø± Ø´Ù‡Ø±
    - Ú©Ø§Ø±Øªâ€ŒÙ‡Ø§ÛŒ Ø­Ù…Ù„ Ùˆ Ù†Ù‚Ù„ Ø¹Ù…ÙˆÙ…ÛŒ
    - Ù†Ú©Ø§Øª Ù…Ù‡Ù… Ø¨Ø±Ø§ÛŒ ØªØ§Ú©Ø³ÛŒ Ùˆ Ø§ÙˆØ¨Ø±

    #### ğŸ¨ Ù¾ÛŒØ´Ù†Ù‡Ø§Ø¯Ø§Øª Ø§Ù‚Ø§Ù…Øª
    - Ø¨Ù‡ØªØ±ÛŒÙ† Ù…Ù†Ø§Ø·Ù‚ Ø¨Ø±Ø§ÛŒ Ø§Ù‚Ø§Ù…Øª
    - Ø§Ù†ÙˆØ§Ø¹ Ù‡ØªÙ„ Ø¨Ø± Ø§Ø³Ø§Ø³ Ø¨ÙˆØ¯Ø¬Ù‡
    - Ù†Ú©Ø§Øª Ù…Ù‡Ù… Ø±Ø²Ø±Ùˆ

    #### ğŸ’¡ Ù†Ú©Ø§Øª Ùˆ ØªÙˆØµÛŒÙ‡â€ŒÙ‡Ø§ÛŒ Ù…Ù‡Ù…
    - Ù†Ú©Ø§Øª Ø§ÛŒÙ…Ù†ÛŒ
    - Ø¢Ø¯Ø§Ø¨ Ùˆ Ø±Ø³ÙˆÙ… Ù…Ø­Ù„ÛŒ
    - Ú†ÛŒØ²Ù‡Ø§ÛŒÛŒ Ú©Ù‡ Ø¨Ø§ÛŒØ¯ Ø¨Ø§ Ø®ÙˆØ¯ Ø¯Ø§Ø´ØªÙ‡ Ø¨Ø§Ø´ÛŒØ¯
    - Ù†Ú©Ø§Øª Ù…Ø±Ø¨ÙˆØ· Ø¨Ù‡ Ø¢Ø¨ Ùˆ Ù‡ÙˆØ§

    #### ğŸ› Ø®Ø±ÛŒØ¯ Ùˆ Ø³ÙˆØºØ§Øª
    - Ø¨Ù‡ØªØ±ÛŒÙ† Ù…Ø±Ø§Ú©Ø² Ø®Ø±ÛŒØ¯
    - Ø³ÙˆØºØ§Øªâ€ŒÙ‡Ø§ÛŒ Ù…Ø­Ù„ÛŒ
    - Ø¨Ø§Ø²Ø§Ø±Ù‡Ø§ÛŒ Ø³Ù†ØªÛŒ

    #### ğŸ“± Ø§Ø·Ù„Ø§Ø¹Ø§Øª ØªÙ…Ø§Ø³ Ù…ÙÛŒØ¯
    - Ø´Ù…Ø§Ø±Ù‡â€ŒÙ‡Ø§ÛŒ Ø¶Ø±ÙˆØ±ÛŒ
    - Ø¢Ø¯Ø±Ø³â€ŒÙ‡Ø§ÛŒ Ù…Ù‡Ù…
    - Ø§Ù¾Ù„ÛŒÚ©ÛŒØ´Ù†â€ŒÙ‡Ø§ÛŒ Ú©Ø§Ø±Ø¨Ø±Ø¯ÛŒ

    ØªÙˆØ¬Ù‡: Ø¨Ø±Ù†Ø§Ù…Ù‡ Ø±Ø§ Ú©Ø§Ù…Ù„Ø§Ù‹ Ø´Ø®ØµÛŒâ€ŒØ³Ø§Ø²ÛŒ Ú©Ù† Ùˆ Ø¨Ø± Ø§Ø³Ø§Ø³ Ø¢Ø¨ Ùˆ Ù‡ÙˆØ§ÛŒ {weather} Ùˆ Ø¹Ù„Ø§ÛŒÙ‚ {interests} ØªÙ†Ø¸ÛŒÙ… Ú©Ù†. Ù…ØªÙ† Ú©Ø§Ù…Ù„ Ùˆ Ø¬Ø§Ù…Ø¹ Ø¨Ù†ÙˆÛŒØ³ Ùˆ Ø§Ø² Ø¬Ø²Ø¦ÛŒØ§Øª ØºØ§ÙÙ„ Ù†Ø´Ùˆ.

    {format_instructions}"""
).partial(format_instructions=itinerary_parser.get_format_instructions())

def itinerary_node(state: TripState) -> TripState:
    city = state["city"]

    prompt = itinerary_prompt.format(
        days=3,
        city=city,
        interests=", ".join(state["user_interests"]),
        weather=state["weather_info"]
    )

    response = llm.generate_content(prompt).text
    parsed_result = itinerary_parser.parse(response)

    state["final_itinerary"] = parsed_result["itinerary"]
    return state

graph = StateGraph(TripState)

graph.add_node("process_interests", interest_node)
graph.add_node("get_weather", weather_node)
graph.add_node("create_itinerary", itinerary_node)

graph.add_edge(START, "process_interests")
graph.add_edge("process_interests", "get_weather")
graph.add_edge("get_weather", "create_itinerary")
graph.add_edge("create_itinerary", END)

app = graph.compile()

from IPython.display import Image, display
display(Image(app.get_graph().draw_mermaid_png()))

#debug

user_request = "I'm planning a 3â€‘day trip to Istanbul. I like art, coffee, and local culture."
output = app.invoke( {"user_input": user_request}  )

print( output["final_itinerary"] )

def run_agent(query :str):
  output = app.invoke( {"user_input": query}  )
  return output["final_itinerary"]

"""**UserInterface**"""

import gradio as gr, time

def respond(message, history):
    result = run_agent(message)

    partial = ''
    for token in result.split():
        partial += token + ' '
        time.sleep(0.015)
        yield partial

demo = gr.ChatInterface(
    respond,
    title = " âœˆï¸ Ø±Ø§Ù‡Ù†Ù…Ø§ÛŒ Ø³ÙØ± " ,
)

demo.launch(debug=True)